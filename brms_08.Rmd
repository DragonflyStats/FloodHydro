fixef.brmsfit Extract Population-Level Estimates
#### Description 
Extract the population-level (’fixed’) effects from a brmsfit object.
Usage
## S3 method for class 'brmsfit'
fixef(object, summary = TRUE, robust = FALSE,
probs = c(0.025, 0.975), pars = NULL, ...)
#### Arguments
object An object of class brmsfit.
summary Should summary statistics (i.e. means, sds, and 95% intervals) be returned instead
of the raw #### Values? Default is TRUE.
robust If FALSE (the default) the mean is used as the measure of central tendency and
the standard deviation as the measure of variability. If TRUE, the median and the
median absolute deviation (MAD) are applied instead. Only used if summary is
TRUE.
Frechet 63
probs The percentiles to be computed by the quantile function. Only used if summary
is TRUE.
pars Optional names of coefficients to extract. By default, all coefficients are extracted.
... Currently ignored.
#### Value
If summary is TRUE, a matrix with one row per population-level effect and one column per calculated
estimate. If summary is FALSE, a matrix with one row per posterior sample and one column per
population-level effect.
Author(s)
Paul-Christian Buerkner <paul.buerkner@gmail.com>
Examples
## Not run:
fit <- brm(time | cens(censored) ~ age + sex + disease,
data = kidney, family = "exponential")
fixef(fit)
# extract only some coefficients
fixef(fit, pars = c("age", "sex"))
## End(Not run)
Frechet The Frechet Distribution
#### Description 
Density, distribution function, quantile function and random generation for the Frechet distribution
with location loc, scale scale, and shape shape.
Usage
dfrechet(x, loc = 0, scale = 1, shape = 1, log = FALSE)
pfrechet(q, loc = 0, scale = 1, shape = 1, lower.tail = TRUE,
log.p = FALSE)
qfrechet(p, loc = 0, scale = 1, shape = 1, lower.tail = TRUE,
log.p = FALSE)
rfrechet(n, loc = 0, scale = 1, shape = 1)
64 GenExtreme#### Value
#### Arguments
x, q Vector of quantiles.
loc Vector of locations.
scale Vector of scales.
shape Vector of shapes.
log Logical; If TRUE, #### Values are returned on the log scale.
lower.tail Logical; If TRUE (default), return P(X <= x). Else, return P(X > x) .
log.p Logical; If TRUE, #### Values are returned on the log scale.
p Vector of probabilities.
n Number of samples to draw from the distribution.
#### Details
See vignette("brms_families") for #### Details on the parameterization.
GenExtreme#### Value The Generalized Extreme #### Value Distribution
#### Description 
Density, distribution function, and random generation for the generalized extreme #### Value distribution
with location mu, scale sigma and shape xi.
Usage
dgen_extreme_#### Value(x, mu = 0, sigma = 1, xi = 0, log = FALSE)
pgen_extreme_#### Value(q, mu = 0, sigma = 1, xi = 0, lower.tail = TRUE,
log.p = FALSE)
rgen_extreme_#### Value(n, mu = 0, sigma = 1, xi = 0)
#### Arguments
x, q Vector of quantiles.
mu Vector of locations.
sigma Vector of scales.
xi Vector of shapes.
log Logical; If TRUE, #### Values are returned on the log scale.
lower.tail Logical; If TRUE (default), return P(X <= x). Else, return P(X > x) .
log.p Logical; If TRUE, #### Values are returned on the log scale.
n Number of samples to draw from the distribution.
#### Details
See vignette("brms_families") for #### Details on the parameterization.
get_prior 65
get_prior Overview on Priors for brms Models
#### Description 
Get information on all parameters (and parameter classes) for which priors may be specified including
default priors.
Usage
get_prior(formula, data, family = gaussian(), autocor = NULL,
internal = FALSE)
#### Arguments
formula An object of class formula, brmsformula, or mvbrmsformula (or one that can
be coerced to that classes): A symbolic #### Description  of the model to be fitted.
The #### Details of model specification are explained in brmsformula.
data An object of class data.frame (or one that can be coerced to that class) containing
data of all variables used in the model.
* `` family`` A description  of the response distribution and link function to be used in the
model. This can be a family function, a call to a family function or a character
string naming the family. Every family function has a link argument allowing to
specify the link function to be applied on the response variable. If not specified,
default links are used. For #### Details of supported families see brmsfamily. By
default, a linear gaussian model is applied. In multivariate models, family
might also be a list of families.
* ``autocor`` An optional cor_brms object describing the correlation structure within the response
variable (i.e., the ’autocorrelation’). See the documentation of cor_brms
for a #### Description  of the available correlation structures. Defaults to NULL, corresponding
to no correlations. In multivariate models, autocor might also be a
list of autocorrelation structures.
internal A flag indicating if the names of additional internal parameters should be displayed.
Setting priors on these parameters is not recommended
#### Value
A data.frame with columns prior, class, coef, and group and several rows, each providing information
on a parameter (or parameter class) on which priors can be specified. The prior column is
empty except for internal default priors.
See Also
set_prior
66 gp
Examples
## get all parameters and parameters classes to define priors on
(prior <- get_prior(count ~ log_Age_c + log_Base4_c * Trt_c
+ (1|patient) + (1|visit),
data = epilepsy, family = poisson()))
## define a prior on all population-level effects a once
prior$prior[1] <- "normal(0,10)"
## define a specific prior on the population-level effect of Trt_c
prior$prior[5] <- "student_t(10, 0, 5)"
## verify that the priors indeed found their way into Stan's model code
make_stancode(count ~ log_Age_c + log_Base4_c * Trt_c
+ (1|patient) + (1|visit),
data = epilepsy, family = poisson(),
prior = prior)
gp Set up Gaussian process terms in brms
#### Description 
Function used to set up a Gaussian process term in brms. The function does not evaluate its #### Arguments
– it exists purely to help set up a model with Gaussian process terms.
Usage
gp(..., by = NA, cov = "exp_quad", gr = FALSE, scale = TRUE)
#### Arguments
... One or more predictors for the Gaussian process.
by A numeric or factor variable of the same length as each predictor. In the numeric
vector case, the elements multiply the #### Values returned by the Gaussian process.
In the factor variable case, a separate Gaussian process is fitted for each factor
level.
cov Name of the covariance kernel. By default, the exponentiated-quadratic kernel
"exp_quad" is used.
gr Logical; Indicates if auto-grouping should be used (defaults to FALSE). If enabled,
observations sharing the same predictor #### Values will be represented by
the same latent variable in the Gaussian process. This will improve sampling
efficiency drastically if the number of unique predictor combinations is small
relative to the number of observations.
scale Logical; If TRUE (the default), predictors are scaled so that the maximum Euclidean
distance between two points is 1. Since the default prior on lscale expects
scaled predictors, it is recommended tomanually specify priors on lscale,
if scale is set to FALSE.
gp 67
#### Details
A Gaussian process is a stochastic process, which describes the relation between one or more predictors
x = (x1; :::; xd) and a response f(x), where d is the number of predictors. A Gaussian
process is the generalization of the multivariate normal distribution to an infinite number of dimensions.
Thus, it can be interpreted as a prior over functions. Any finite sample realized from this
stochastic process is jointly multivariate normal, with a covariance matrix defined by the covariance
kernel kp(x), where p is the vector of parameters of the Gaussian process:
f(x) MV N(0; kp(x))
The smoothness and general behavior of the function f depends only on the choice of covariance
kernel. For a more detailed introduction to Gaussian processes, see https://en.wikipedia.org/
wiki/Gaussian_process.
Below, we describe the currently supported covariance kernels:
• "exp_quad": The exponentiated-quadratic kernel is defined as k(xi; xj) = sdgp2exp(􀀀jjxi􀀀
xj jj=(2lscale2)), where jj:jj is the Euclidean norm, sdgp is a standard deviation parameter,
and lscale is characteristic length-scale parameter. The latter practically measures how close
two points xi and xj have to be to influence each other substantially.
In the current implementation, "exp_quad" is the only supported covariance kernel. More options
will follow in the future.
#### Value
An object of class 'gpterm', which is a list of #### Arguments to be interpreted by the formula parsing
functions of brms.
See Also
brmsformula
Examples
## Not run:
# simulate data using the mgcv package
dat <- mgcv::gamSim(1, n = 30, scale = 2)
# fit a simple gaussian process model
fit1 <- brm(y ~ gp(x2), dat, chains = 2)
summary(fit1)
me1 <- marginal_effects(fit1, nsamples = 200, spaghetti = TRUE)
plot(me1, ask = FALSE, points = TRUE)
# fit a more complicated gaussian process model
fit2 <- brm(y ~ gp(x0) + x1 + gp(x2) + x3, dat, chains = 2)
summary(fit2)
me2 <- marginal_effects(fit2, nsamples = 200, spaghetti = TRUE)
plot(me2, ask = FALSE, points = TRUE)
# fit a multivariate gaussian process model
68 gr
fit3 <- brm(y ~ gp(x1, x2), dat, chains = 2)
summary(fit3)
me3 <- marginal_effects(fit3, nsamples = 200, spaghetti = TRUE)
plot(me3, ask = FALSE, points = TRUE)
# compare model fit
LOO(fit1, fit2, fit3)
# simulate data with a factor covariate
dat2 <- mgcv::gamSim(4, n = 90, scale = 2)
# fit separate gaussian processes for different levels of 'fac'
fit4 <- brm(y ~ gp(x2, by = fac), dat2, chains = 2)
summary(fit4)
plot(marginal_effects(fit4), points = TRUE)
## End(Not run)
gr Set up basic grouping terms in brms
#### Description 
Function used to set up a basic grouping term in brms. The function does not evaluate its #### Arguments
– it exists purely to help set up a model with grouping terms. gr is called implicitly inside the
package and there is usually no need to call it directly.
Usage
gr(..., by = NULL, dist = "gaussian")
#### Arguments
... One or more terms containing grouping factors.
by An optional factor variable, specifying sub-populations of the groups. For each
level of the by variable, a separate variance-covariance matrix will be fitted.
Levels of the grouping factor must be nested in levels of the by variable.
dist Name of the distribution of the group-level effects. Currently "gaussian" is the
only option.
See Also
brmsformula
horseshoe 69
Examples
## Not run:
# model using basic lme4-style formula
fit1 <- brm(count ~ Trt + (1|patient), data = epilepsy)
summary(fit1)
# equivalent model using 'gr' which is called anyway internally
fit2 <- brm(count ~ Trt + (1|gr(patient)), data = epilepsy)
summary(fit2)
# include Trt as a by variable
fit3 <- brm(count ~ Trt + (1|gr(patient, by = Trt)), data = epilepsy)
summary(fit3)
## End(Not run)
horseshoe Set up a horseshoe prior in brms
#### Description 
Function used to set up a horseshoe prior for population-level effects in brms. The function does
not evaluate its #### Arguments – it exists purely to help set up the model.
Usage
horseshoe(df = 1, scale_global = 1, df_global = 1, scale_slab = 2,
df_slab = 4, par_ratio = NULL, autoscale = TRUE)
#### Arguments
df Degrees of freedom of student-t prior of the local shrinkage parameters. Defaults
to 1.
scale_global Scale of the student-t prior of the global shrinkage parameter. Defaults to 1.
In linear models, scale_global will internally be multiplied by the residual
standard deviation parameter sigma.
df_global Degrees of freedom of student-t prior of the global shrinkage parameter. Defaults
to 1.
scale_slab Scale of the student-t prior of the regularization parameter. Defaults to 2.
df_slab Degrees of freedom of the student-t prior of the regularization parameter. Defaults
to 4.
par_ratio Ratio of the expected number of non-zero coefficients to the expected number of
zero coefficients. If specified, scale_global is ignored and internally computed
as par_ratio / sqrt(N), where N is the total number of observations in the
data.
70 horseshoe
autoscale Logical; indicating whether the horseshoe prior should be scaled using the residual
standard deviation sigma if possible and sensible (defaults to TRUE). Autoscaling
is not applied for distributional parameters or when the model does
not contain the parameter sigma.
#### Details
The horseshoe prior is a special shrinkage prior initially proposed by Carvalho et al. (2009). It
is symmetric around zero with fat tails and an infinitely large spike at zero. This makes it ideal
for sparse models that have many regression coefficients, although only a minority of them is nonzero.
The horseshoe prior can be applied on all population-level effects at once (excluding the
intercept) by using set_prior("horseshoe(1)"). The 1 implies that the student-t prior of the local
shrinkage parameters has 1 degrees of freedom. This may, however, lead to an increased number
of divergent transition in Stan. Accordingly, increasing the degrees of freedom to slightly higher
#### Values (e.g., 3) may often be a better option, although the prior no longer resembles a horseshoe in
this case. Further, the scale of the global shrinkage parameter plays an important role in amount
of shrinkage applied. It defaults to 1, but this may result in too few shrinkage (Piironen & Vehtari,
2016). It is thus possible to change the scale using argument scale_global of the horseshoe
prior, for instance horseshoe(1, scale_global = 0.5). In linear models, scale_global will
internally be multiplied by the residual standard deviation parameter sigma. See Piironen and
Vehtari (2016) for recommendations how to properly set the global scale. The degrees of freedom
of the global shrinkage prior may also be adjusted via argument df_global. Piironen and Vehtari
(2017) recommend to specifying the ratio of the expected number of non-zero coefficients to the
expected number of zero coefficients par_ratio rather than scale_global directly. As proposed
by Piironen and Vehtari (2017), an additional regularization is applied that only affects non-zero
coefficients. The amount of regularization can be controlled via scale_slab and df_slab. To
make sure that shrinkage can equally affect all coefficients, predictors should be one the same
scale. Generally, models with horseshoe priors a more likely than other models to have divergent
transitions so that increasing adapt_delta from 0.8 to #### Values closer to 1 will often be necessary.
See the documentation of brm for instructions on how to increase adapt_delta.
#### Value
A character string obtained by match.call() with additional #### Arguments.
References
Carvalho, C. M., Polson, N. G., & Scott, J. G. (2009). Handling sparsity via the horseshoe. In
International Conference on Artificial Intelligence and Statistics (pp. 73-80).
Piironen J. & Vehtari A. (2016). On the Hyperprior Choice for the Global Shrinkage Parameter in
the Horseshoe Prior. https://arxiv.org/pdf/1610.05559v1.pdf
Piironen, J., and Vehtari, A. (2017). Sparsity information and regularization in the horseshoe and
other shrinkage priors. https://arxiv.org/abs/1707.01694
See Also
set_prior
Hurdle 71
Examples
set_prior(horseshoe(df = 3, par_ratio = 0.1))
Hurdle Hurdle Distributions
#### Description 
Density and distribution functions for hurdle distributions.
Usage
dhurdle_poisson(x, lambda, hu, log = FALSE)
phurdle_poisson(q, lambda, hu, lower.tail = TRUE, log.p = FALSE)
dhurdle_negbinomial(x, mu, shape, hu, log = FALSE)
phurdle_negbinomial(q, mu, shape, hu, lower.tail = TRUE, log.p = FALSE)
dhurdle_gamma(x, shape, scale, hu, log = FALSE)
phurdle_gamma(q, shape, scale, hu, lower.tail = TRUE, log.p = FALSE)
dhurdle_lognormal(x, mu, sigma, hu, log = FALSE)
phurdle_lognormal(q, mu, sigma, hu, lower.tail = TRUE, log.p = FALSE)
#### Arguments
x Vector of quantiles.
hu hurdle propability
log Logical; If TRUE, #### Values are returned on the log scale.
q Vector of quantiles.
lower.tail Logical; If TRUE (default), return P(X <= x). Else, return P(X > x) .
log.p Logical; If TRUE, #### Values are returned on the log scale.
mu, lambda location parameter
shape shape parameter
sigma, scale scale parameter
#### Details
The density of a hurdle distribution can be specified as follows. If x = 0 set f(x) = . Else set
f(x) = (1 􀀀 )  g(x)=(1 􀀀 G(0)) where g(x) and G(x) are the density and distribution function
of the non-hurdle part, respectively.
72 hypothesis.brmsfit
hypothesis.brmsfit Non-Linear Hypothesis Testing
#### Description 
Perform non-linear hypothesis testing for all model parameters.
Usage
## S3 method for class 'brmsfit'
hypothesis(x, hypothesis, class = "b", group = "",
scope = c("standard", "ranef", "coef"), alpha = 0.05, seed = NULL,
...)
hypothesis(x, ...)
## Default S3 method:
hypothesis(x, hypothesis, alpha = 0.05, ...)
#### Arguments
x An R object. If it is no brmsfit object, it must be coercible to a data.frame.
hypothesis A character vector specifying one or more non-linear hypothesis concerning
parameters of the model.
class A string specifying the class of parameters being tested. Default is "b" for
population-level effects. Other typical options are "sd" or "cor". If class = NULL,
all parameters can be tested against each other, but have to be specified with their
full name (see also parnames)
group Name of a grouping factor to evaluate only group-level effects parameters related
to this grouping factor. Ignored if class is not "sd" or "cor".
scope Indicates where to look for the variables specified in hypothesis. If "standard",
use the full parameter names (subject to the restriction given by class). If
"coef" or "ranef" compute the hypothesis for all levels of the grouping factor
given in "group", based on the output of coef.brmsfit and ranef.brmsfit,
respectively.
alpha The alpha-level of the tests (default is 0.05; see ’#### Details’ for more information).
seed A single numeric #### Value passed to set.seed to make results reproducible.
... Currently ignored.
#### Details
Among others, hypothesis computes an evidence ratio (Evid.Ratio) for each hypothesis. For a
directed hypothesis, this is just the posterior probability (Post.Prob) under the hypothesis against
its alternative. That is, when the hypothesis if of the form a > b, the evidence ratio is the ratio of the
posterior probability of a > b and the posterior probability of a < b. In this example, #### Values greater
hypothesis.brmsfit 73
than one indicate that the evidence in favor of a > b is larger than evidence in favor of a < b. For
an undirected (point) hypothesis, the evidence ratio is a Bayes factor between the hypothesis and its
alternative computed via the Savage-Dickey density ratio method. That is the posterior density at
the point of interest divided by the prior density at that point. #### Values greater than one indicate that
evidence in favor of the point hypothesis has increased after seeing the data. In order to calculate
this Bayes factor, all parameters related to the hypothesis must have proper priors and argument
sample_prior of function brm must be set to TRUE. When interpreting Bayes factors, make sure
that your priors are reasonable and carefully chosen, as the result will depend heavily on the priors.
In particular, avoid using default priors.
The argument alpha specifies the size of the credible interval (i.e., Bayesian confidence interval).
For instance, if alpha = 0.05 (5%), the credible interval will contain 1 - alpha = 0.95 (95%) of
the posterior #### Values. Hence, alpha * 100% of the posterior #### Values will lie outside of the credible
interval. Although this allows testing of hypotheses in a similar manner as in the frequentist nullhypothesis
testing framework, we strongly argue against using arbitrary cutoffs (e.g., p < .05) to
determine the ’existence’ of an effect.
#### Value
A brmshypothesis object.
Author(s)
Paul-Christian Buerkner <paul.buerkner@gmail.com>
See Also
brmshypothesis
Examples
## Not run:
## define priors
prior <- c(set_prior("normal(0,2)", class = "b"),
set_prior("student_t(10,0,1)", class = "sigma"),
set_prior("student_t(10,0,1)", class = "sd"))
## fit a linear mixed effects models
fit <- brm(time ~ age + sex + disease + (1 + age|patient),
data = kidney, family = lognormal(),
prior = prior, sample_prior = TRUE,
control = list(adapt_delta = 0.95))
## perform two-sided hypothesis testing
(hyp1 <- hypothesis(fit, "sexfemale = age + diseasePKD"))
plot(hyp1)
hypothesis(fit, "exp(age) - 3 = 0", alpha = 0.01)
## perform one-sided hypothesis testing
hypothesis(fit, "diseasePKD + diseaseGN - 3 < 0")
hypothesis(fit, "age < Intercept",
74 inhaler
class = "sd", group = "patient")
## test the amount of random intercept variance on all variance
h <- paste("sd_patient__Intercept^2 / (sd_patient__Intercept^2 +",
"sd_patient__age^2 + sigma^2) = 0")
(hyp2 <- hypothesis(fit, h, class = NULL))
plot(hyp2)
## test more than one hypothesis at once
h <- c("diseaseGN = diseaseAN", "2 * diseaseGN - diseasePKD = 0")
(hyp3 <- hypothesis(fit, h))
plot(hyp3, ignore_prior = TRUE)
## compute hypotheses for all levels of a grouping factor
hypothesis(fit, "age = 0", scope = "coef", group = "patient")
## use the default method
dat <- as.data.frame(fit)
hypothesis(dat, "b_age > 0")
## End(Not run)
